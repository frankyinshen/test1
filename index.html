<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v4.4.3</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #000; padding: 3px 10px; border-radius: 12px; color: #fff; font-weight: bold; letter-spacing: 0.5px;}

        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        .btn-export-all { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; }

        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5; text-align: left;}
        .cn-meaning { color: #d9534f; font-weight: bold; margin-bottom: 5px; display: block; }

        /* TTS åˆ‡æ¢åŒº */
        .tts-box { margin-top: 14px; background: #f2f2f7; border-radius: 14px; padding: 12px 16px; }
        .tts-toggle-row { display: flex; align-items: center; justify-content: center; gap: 10px; }
        .tts-lbl { font-size: 13px; font-weight: 600; color: #bbb; transition: color .2s; }
        .tts-lbl.active { color: #007aff; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; border-radius: 28px; transition: .3s; }
        .slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: .3s; box-shadow: 0 1px 4px rgba(0,0,0,0.2); }
        input:checked + .slider { background: #007aff; }
        input:checked + .slider:before { transform: translateX(22px); }
        .tts-sub { margin-top: 8px; font-size: 12px; color: #636366; display: flex; align-items: center; justify-content: center; gap: 6px; flex-wrap: wrap; }
        .tts-sub select { border: 1px solid #d1d1d6; border-radius: 8px; padding: 3px 8px; font-size: 12px; background: white; color: #333; max-width: 240px; }
        #voiceStatus { margin-top: 6px; font-size: 11px; color: #aaa; min-height: 14px; }

        /* è°ƒè¯• */
        #voiceDebug { font-size: 11px; color: #555; margin-top: 8px; white-space: pre-wrap; text-align: left; background: #f2f2f7; padding: 8px 10px; border-radius: 8px; display: none; word-break: break-all; }
        #listVoicesBtn { margin-top: 8px; background: #f2f2f7; border: none; padding: 7px 14px; border-radius: 8px; font-size: 13px; cursor: pointer; color: #555; }

        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }

        .word-list { text-align: left; }
        .archive-group { margin-top: 25px; border: 1px solid #e5e5ea; border-radius: 12px; overflow: hidden; }
        .archive-header { background: #f8f8f8; padding: 12px 15px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e5ea;}
        .archive-title { flex: 1; display: flex; align-items: center; gap: 5px; }
        .archive-actions { display: flex; gap: 8px; }
        .word-item { padding: 15px; border-bottom: 1px solid #f2f2f7; display: flex; justify-content: space-between; align-items: flex-start;}
        .word-item:last-child { border-bottom: none; }
        .word-content { display: flex; flex-direction: column; flex: 1; margin-right: 10px; }
        .word-header { display: flex; align-items: center; gap: 8px; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        .audio-btn { background: #e5f1ff; color: #007aff; border: none; border-radius: 50%; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; line-height: 1.5; }
        .word-meaning-cn { color: #d9534f; font-weight: 600; margin-bottom: 3px; }
        .action-btns { display: flex; gap: 5px; }
        .icon-btn { background: #f2f2f7; border: none; font-size: 14px; cursor: pointer; padding: 6px 10px; border-radius: 8px; }
    </style>
</head>
<body>

<div class="card">
    <h2>
        ğŸ™ï¸ è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬
        <span class="version-tag">v4.4.3</span>
    </h2>
    <div class="input-group"><label for="archiveName">å½’æ¡£åç§°:</label><input type="text" id="archiveName"></div>
    <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
    <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
    <div id="rawTranscript"></div>
    <div id="resultWord">...</div>
    <div id="meaning">éœ€è¦ç©ºæ ¼æ—¶ï¼Œè¯·è¯» "zip"</div>

    <!-- TTS åˆ‡æ¢åŒº -->
    <div class="tts-box">
        <div class="tts-toggle-row">
            <span class="tts-lbl active" id="lblSystem">ğŸ–¥ ç³»ç»ŸéŸ³è‰²</span>
            <label class="switch">
                <input type="checkbox" id="ttsToggle">
                <span class="slider"></span>
            </label>
            <span class="tts-lbl" id="lblOnline">ğŸŒ åœ¨çº¿TTS</span>
        </div>
        <div class="tts-sub" id="systemVoiceSub">
            éŸ³è‰²é€‰æ‹©:
            <select id="systemVoiceSelect"></select>
        </div>
        <div class="tts-sub" id="onlineVoiceSub" style="display:none;">
            åœ¨çº¿éŸ³è‰²:
            <select id="onlineVoiceSelect">
                <option value="youdao_en">æœ‰é“Â·è‹±è¯­å¥³å£°ï¼ˆå›½å†…æ¨èâ­ï¼‰</option>
                <option value="youdao_en2">æœ‰é“Â·è‹±è¯­ç”·å£°</option>
                <option value="stream_Joanna">PollyÂ·Joannaï¼ˆç¾å¼å¥³å£°ï¼‰</option>
                <option value="stream_Salli">PollyÂ·Salliï¼ˆç¾å¼å¥³å£°ï¼‰</option>
                <option value="stream_Matthew">PollyÂ·Matthewï¼ˆç¾å¼ç”·å£°ï¼‰</option>
                <option value="stream_Amy">PollyÂ·Amyï¼ˆè‹±å¼å¥³å£°ï¼‰</option>
                <option value="stream_Brian">PollyÂ·Brianï¼ˆè‹±å¼ç”·å£°ï¼‰</option>
                <option value="stream_Nicole">PollyÂ·Nicoleï¼ˆæ¾³æ´²å¥³å£°ï¼‰</option>
            </select>
        </div>
        <div id="voiceStatus"></div>
    </div>

    <div id="voiceDebug"></div>
    <button id="listVoicesBtn">ğŸ” åˆ—å‡ºæ‰€æœ‰è‹±æ–‡éŸ³è‰²ï¼ˆè°ƒè¯•ï¼‰</button>
</div>

<div class="card word-list">
    <h2>ğŸ“š ä½ çš„ç”Ÿè¯æœ¬ <button id="exportBtn" class="btn-export-all">ğŸ’¾ å¯¼å‡ºå…¨éƒ¨</button></h2>
    <div id="vocabList"></div>
</div>

<script>
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('archiveName').value = today;

    const recordBtn            = document.getElementById('recordBtn');
    const exportBtn            = document.getElementById('exportBtn');
    const statusText           = document.getElementById('statusText');
    const rawTranscriptDisplay = document.getElementById('rawTranscript');
    const resultWordDisplay    = document.getElementById('resultWord');
    const meaningDisplay       = document.getElementById('meaning');
    const vocabListDisplay     = document.getElementById('vocabList');
    const voiceDebug           = document.getElementById('voiceDebug');
    const voiceStatus          = document.getElementById('voiceStatus');
    const ttsToggle            = document.getElementById('ttsToggle');
    const lblSystem            = document.getElementById('lblSystem');
    const lblOnline            = document.getElementById('lblOnline');
    const systemVoiceSub       = document.getElementById('systemVoiceSub');
    const onlineVoiceSub       = document.getElementById('onlineVoiceSub');
    const systemVoiceSelect    = document.getElementById('systemVoiceSelect');
    const onlineVoiceSelect    = document.getElementById('onlineVoiceSelect');

    // â”€â”€ è®¾å¤‡æ£€æµ‹ â”€â”€
    function getDeviceType() {
        const ua = navigator.userAgent;
        if (/iPad/.test(ua)) return 'iPad';
        if (/iPhone/.test(ua)) return 'iPhone';
        if (/Macintosh/.test(ua) && navigator.maxTouchPoints > 1) return 'iPad';
        return 'other';
    }
    const DEVICE_TYPE = getDeviceType();
    // æ˜¯å¦æ˜¯è§¦æ‘¸è®¾å¤‡ï¼ˆiPhone / iPadï¼‰
    const IS_TOUCH = (DEVICE_TYPE === 'iPhone' || DEVICE_TYPE === 'iPad');

    // â”€â”€ TTS åˆ‡æ¢ â”€â”€
    ttsToggle.addEventListener('change', () => {
        const online = ttsToggle.checked;
        lblSystem.classList.toggle('active', !online);
        lblOnline.classList.toggle('active', online);
        systemVoiceSub.style.display = online ? 'none' : 'flex';
        onlineVoiceSub.style.display = online ? 'flex' : 'none';
        voiceStatus.innerText = '';
    });

    // â”€â”€ åŠ è½½ç³»ç»ŸéŸ³è‰²åˆ°ä¸‹æ‹‰åˆ—è¡¨ â”€â”€
    function loadSystemVoices() {
        const voices = window.speechSynthesis.getVoices();
        if (!voices || voices.length === 0) return;
        const enVoices = voices.filter(v => v.lang.startsWith('en'));
        if (enVoices.length === 0) return;
        enVoices.sort((a, b) => {
            const score = v => v.lang === 'en-US' ? 0 : v.lang === 'en-GB' ? 1 : 2;
            return score(a) - score(b) || a.name.localeCompare(b.name);
        });
        systemVoiceSelect.innerHTML = '';
        enVoices.forEach(v => {
            const opt = document.createElement('option');
            opt.value = v.name;
            opt.textContent = `${v.name} (${v.lang})`;
            systemVoiceSelect.appendChild(opt);
        });
        // é»˜è®¤é€‰ Kathy(en-US) > Sandy(en-US) > ç¬¬ä¸€ä¸ªen-US
        const preferred = ['Kathy', 'Sandy', 'Samantha'];
        for (const name of preferred) {
            const found = enVoices.find(v => v.name === name && v.lang === 'en-US')
                       || enVoices.find(v => v.name === name);
            if (found) { systemVoiceSelect.value = found.name; break; }
        }
    }
    window.speechSynthesis.onvoiceschanged = loadSystemVoices;
    loadSystemVoices();

    // â”€â”€ æœ—è¯»å…¥å£ â”€â”€
    let currentAudio = null;

    function speakWord(word) {
        if (ttsToggle.checked) {
            speakOnline(word);
        } else {
            speakSystem(word);
        }
    }

    // ç³»ç»Ÿ TTS
    function speakSystem(word) {
        window.speechSynthesis.cancel();
        if (currentAudio) { currentAudio.pause(); currentAudio = null; }
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        utterance.rate = 0.9;

        if (DEVICE_TYPE === 'iPhone') {
            window.speechSynthesis.speak(utterance);
            return;
        }
        const selectedName = systemVoiceSelect.value;
        const voices = window.speechSynthesis.getVoices();
        const chosen = voices.find(v => v.name === selectedName) || null;
        if (chosen) {
            utterance.voice = chosen;
            voiceStatus.innerText = `ğŸ”Š ${chosen.name} (${chosen.lang})`;
        } else {
            voiceStatus.innerText = 'ğŸ”Š ç³»ç»Ÿé»˜è®¤';
        }
        window.speechSynthesis.speak(utterance);
    }

    // åœ¨çº¿ TTS
    // ä¸»çº¿ï¼šæœ‰é“è¯å…¸ï¼ˆå›½å†…ç¨³å®šï¼‰ï¼›Polly ç³»åˆ—å¤‡ç”¨ï¼ˆéœ€ç¿»å¢™ï¼‰
    function speakOnline(word) {
        window.speechSynthesis.cancel();
        if (currentAudio) { currentAudio.pause(); currentAudio = null; }

        const val = onlineVoiceSelect.value;
        let url = '';

        if (val === 'youdao_en') {
            // æœ‰é“Â·å¥³å£° (type=2 ç¾å¼å¥³å£°, type=1 è‹±å¼å¥³å£°)
            url = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=2`;
        } else if (val === 'youdao_en2') {
            url = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=1`;
        } else {
            // Polly / StreamElements
            const voice = val.replace('stream_', '');
            url = `https://api.streamelements.com/kappa/v2/speech?voice=${voice}&text=${encodeURIComponent(word)}`;
        }

        voiceStatus.innerText = `â³ åŠ è½½ä¸­...`;
        const audio = new Audio(url);
        currentAudio = audio;
        audio.playbackRate = 0.9;
        audio.oncanplaythrough = () => {
            audio.play().catch(() => { voiceStatus.innerText = 'âš ï¸ æµè§ˆå™¨é˜»æ­¢è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·å†ç‚¹ä¸€æ¬¡ğŸ”Š'; });
            voiceStatus.innerText = `ğŸ”Š åœ¨çº¿: ${val.replace('stream_','').replace('youdao_en','æœ‰é“')}`;
        };
        audio.onerror = () => {
            voiceStatus.innerText = 'âŒ åœ¨çº¿TTSå¤±è´¥ï¼Œå·²è‡ªåŠ¨æ”¹ç”¨ç³»ç»ŸéŸ³è‰²';
            // å¤±è´¥æ—¶è‡ªåŠ¨å›é€€åˆ°ç³»ç»ŸéŸ³è‰²
            speakSystem(word);
        };
        // 3ç§’è¶…æ—¶ä¿é™©
        setTimeout(() => {
            if (currentAudio === audio && audio.readyState < 3) {
                audio.pause();
                voiceStatus.innerText = 'â± è¶…æ—¶ï¼Œå·²æ”¹ç”¨ç³»ç»ŸéŸ³è‰²';
                speakSystem(word);
            }
        }, 3000);
    }

    // â”€â”€ è°ƒè¯•æŒ‰é’® â”€â”€
    document.getElementById('listVoicesBtn').addEventListener('click', () => {
        const doList = () => {
            const all = window.speechSynthesis.getVoices();
            const en = all.filter(v => v.lang.startsWith('en'));
            voiceDebug.style.display = 'block';
            voiceDebug.innerText = en.length === 0
                ? 'âš ï¸ æœªæ‰¾åˆ°ä»»ä½•è‹±æ–‡éŸ³è‰²ï¼Œè¯·ç¨åå†è¯•ã€‚'
                : `å…±æ‰¾åˆ° ${en.length} ä¸ªè‹±æ–‡éŸ³è‰²ï¼š\n` +
                  en.map((v, i) => `${i+1}. "${v.name}" | ${v.lang}`).join('\n');
        };
        const voices = window.speechSynthesis.getVoices();
        if (voices && voices.length > 0) { doList(); }
        else {
            voiceDebug.style.display = 'block';
            voiceDebug.innerText = 'â³ æ­£åœ¨åŠ è½½éŸ³è‰²åˆ—è¡¨...';
            window.speechSynthesis.onvoiceschanged = () => { window.speechSynthesis.onvoiceschanged = null; doList(); };
        }
    });

    // â”€â”€ è¯­éŸ³è¯†åˆ« â”€â”€
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isSystemBusy = false;
    let fallbackTimer = null;
    let hasActuallyStarted = false;

    function resetRecognition() {
        if (recognition) {
            recognition.onstart = null; recognition.onresult = null;
            recognition.onerror = null; recognition.onend = null;
            try { recognition.abort(); } catch(e){}
            recognition = null;
        }
        clearTimeout(fallbackTimer);
    }

    const startRecording = (e) => {
        e.preventDefault();
        if (isSystemBusy) return;
        isSystemBusy = true; hasActuallyStarted = false;
        rawTranscriptDisplay.innerText = "";
        resetRecognition();
        if (!SpeechRecognition) { statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚"; isSystemBusy = false; return; }

        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.continuous = false;

        recognition.onstart = () => {
            hasActuallyStarted = true;
            recordBtn.classList.add('recording');
            recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬...";
            statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
        };

        recognition.onresult = async (event) => {
            clearTimeout(fallbackTimer);
            let transcript = event.results[0][0].transcript.toLowerCase().trim();
            rawTranscriptDisplay.innerText = `[å¬åˆ°å†…å®¹]: "${transcript}"`;

            // ã€Windowsä¿®å¤ã€‘è‹¥è¯†åˆ«ç»“æœæ˜¯æ¯ä¸ªå­—æ¯ç”¨ç©ºæ ¼éš”å¼€ï¼ˆå¦‚ "t h i n k"ï¼‰ï¼Œç›´æ¥åˆå¹¶
            const rawTokens = transcript.split(/\s+/).filter(t => t.length > 0);
            let word;
            if (rawTokens.length > 1 && rawTokens.every(t => t.length === 1 && /[a-z]/.test(t))) {
                word = rawTokens.join('');
            } else {
                let processed = transcript.replace(/\bzip\b/g, '_');
                word = processed.replace(/[^a-z\s_]/g, '');
                word = word.replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
                // å…œåº•å†æ£€æµ‹ä¸€æ¬¡ï¼ˆWindowsæœ‰æ—¶ä¼šè¾“å‡º "t.h.i.n.k" ç­‰å˜ä½“ï¼‰
                const tokens2 = word.split(' ').filter(t => t.length > 0);
                if (tokens2.length > 1 && tokens2.every(t => t.length === 1)) {
                    word = tokens2.join('');
                }
            }

            if (!word) { statusText.innerText = "âš ï¸ æœªè¯†åˆ«å‡ºæœ‰æ•ˆå­—ç¬¦ã€‚"; return; }
            resultWordDisplay.innerText = word;
            statusText.innerText = "æ­£åœ¨ç¿»è¯‘æŸ¥è¯¢ä¸­...";
            await processWord(word);
        };

        recognition.onerror = (event) => {
            clearTimeout(fallbackTimer);
            if (event.error === 'aborted') {
                statusText.innerText = "âš ï¸ å·²å–æ¶ˆï¼Œè¯·é‡æ–°æŒ‰ä½";
            } else if (event.error === 'no-speech') {
                statusText.innerText = "âš ï¸ æœªæ£€æµ‹åˆ°è¯­éŸ³ï¼Œè¯·é‡è¯•";
            } else {
                statusText.innerText = `âŒ è¯†åˆ«é”™è¯¯: ${event.error}`;
            }
        };

        recognition.onend = () => {
            clearTimeout(fallbackTimer);
            isSystemBusy = false;
            recordBtn.classList.remove('busy', 'recording');
            recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
            if (statusText.innerText.includes("ç­‰å¾…ç³»ç»Ÿå›ä¼ ")) {
                statusText.innerText = "âš ï¸ ç³»ç»Ÿæœªè¿”å›æ•°æ®ï¼Œè¯·é‡è¯»";
            }
        };

        try { recognition.start(); } catch (err) { isSystemBusy = false; statusText.innerText = "âŒ å¯åŠ¨å¤±è´¥ï¼Œè¯·é‡è¯•"; }
    };

    const stopRecording = (e) => {
        e.preventDefault();
        if (!isSystemBusy) return;
        if (!hasActuallyStarted) {
            resetRecognition(); isSystemBusy = false;
            recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
            statusText.innerText = "æƒé™å·²æ›´æ–°ï¼Œè¯·é‡æ–°æŒ‰ä½ã€‚";
            return;
        }
        recordBtn.classList.remove('recording');
        recordBtn.classList.add('busy');
        recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
        statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿå›ä¼ ...";
        fallbackTimer = setTimeout(() => {
            if (isSystemBusy && recognition) { try { recognition.stop(); } catch(err){} }
        }, 2500);
    };

    // â”€â”€ äº‹ä»¶ç»‘å®šï¼šè§¦æ‘¸è®¾å¤‡ä¸ç»‘ mouseleaveï¼ˆé˜²è¯¯è§¦ï¼‰â”€â”€
    recordBtn.addEventListener('mousedown', startRecording);
    recordBtn.addEventListener('touchstart', startRecording, {passive: false});
    recordBtn.addEventListener('mouseup', stopRecording);
    recordBtn.addEventListener('touchend', stopRecording);
    recordBtn.addEventListener('touchcancel', stopRecording);
    // mouseleave ä»…åœ¨éè§¦æ‘¸è®¾å¤‡ç»‘å®šï¼ˆiPhone/iPad ä¸Šä¼šè¯¯è§¦å‘å¯¼è‡´æå‰ç»“æŸï¼‰
    if (!IS_TOUCH) {
        recordBtn.addEventListener('mouseleave', stopRecording);
    }

    // â”€â”€ è¯æ±‡å¤„ç† â”€â”€
    async function processWord(word, specificArchive = null) {
        let enMeaning = "æš‚æ— è‹±æ–‡é‡Šä¹‰ã€‚", cnMeaning = "æš‚æ— ä¸­æ–‡é‡Šä¹‰ã€‚";
        const safeWordUrl = encodeURIComponent(word);
        try {
            const transRes = await fetch(`https://api.mymemory.translated.net/get?q=${safeWordUrl}&langpair=en|zh-CN`);
            const transData = await transRes.json();
            if (transData && transData.responseData) {
                let text = transData.responseData.translatedText;
                if (text.toLowerCase() !== word.toLowerCase()) cnMeaning = text;
            }
            try {
                const dictRes = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${safeWordUrl}`);
                if (dictRes.ok) {
                    const dictData = await dictRes.json();
                    enMeaning = dictData[0].meanings[0].definitions[0].definition;
                }
            } catch(e) {}
            statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
        } catch (error) { statusText.innerText = "âš ï¸ ç½‘ç»œå¼‚å¸¸ï¼Œä»…ä¿å­˜æ‹¼å†™"; }
        const combinedMeaning = `ã€ä¸­ã€‘${cnMeaning}\nã€è‹±ã€‘${enMeaning}`;
        meaningDisplay.innerHTML = `<span class="cn-meaning">${cnMeaning}</span><span class="en-meaning">${enMeaning}</span>`;
        resultWordDisplay.innerText = word;
        saveWord(word, combinedMeaning, specificArchive);
        renderVocabList();
    }

    function saveWord(word, meaning, specificArchive) {
        const archiveName = specificArchive || (document.getElementById('archiveName').value || today);
        let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
        if (!vocabData[archiveName]) vocabData[archiveName] = [];
        vocabData[archiveName] = vocabData[archiveName].filter(w => w.word !== word);
        vocabData[archiveName].unshift({ word, meaning });
        localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
        let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
        order = order.filter(name => name !== archiveName);
        order.unshift(archiveName);
        localStorage.setItem('myVocabBook_order', JSON.stringify(order));
    }

    function editWord(archive, oldWord) {
        const newWord = prompt(`è¯·ä¿®æ”¹ "${oldWord}"ï¼š`, oldWord);
        if (newWord && newWord.trim() !== "" && newWord !== oldWord) {
            const cleanWord = newWord.replace(/[^a-zA-Z\s]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
            if (!cleanWord) { alert("åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ï¼"); return; }
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabData[archive] = vocabData[archive].filter(item => item.word !== oldWord);
            if (vocabData[archive].length === 0) delete vocabData[archive];
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            statusText.innerText = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${cleanWord} ...`;
            processWord(cleanWord, archive);
        }
    }

    function deleteWord(archive, word) {
        if (confirm(`ç¡®å®šåˆ é™¤å•è¯ "${word}" å—ï¼Ÿ`)) {
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabData[archive] = vocabData[archive].filter(item => item.word !== word);
            if (vocabData[archive].length === 0) {
                delete vocabData[archive];
                let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                order = order.filter(name => name !== archive);
                localStorage.setItem('myVocabBook_order', JSON.stringify(order));
            }
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            renderVocabList();
        }
    }

    function renameArchive(oldName) {
        const newName = prompt("è¯·è¾“å…¥æ–°çš„å½’æ¡£åç§°ï¼š", oldName);
        if (newName && newName.trim() && newName !== oldName) {
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (vocabData[newName]) { alert("è¯¥å½’æ¡£åç§°å·²å­˜åœ¨ï¼"); return; }
            vocabData[newName] = vocabData[oldName];
            delete vocabData[oldName];
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            const index = order.indexOf(oldName);
            if (index > -1) order[index] = newName;
            localStorage.setItem('myVocabBook_order', JSON.stringify(order));
            if (document.getElementById('archiveName').value === oldName) document.getElementById('archiveName').value = newName;
            renderVocabList();
        }
    }

    function deleteArchive(name) {
        if (confirm(`âš ï¸ å±é™©æ“ä½œï¼š\nç¡®å®šè¦å½»åº•åˆ é™¤å½’æ¡£ã€${name}ã€‘å—ï¼Ÿ`)) {
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            delete vocabData[name];
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            order = order.filter(n => n !== name);
            localStorage.setItem('myVocabBook_order', JSON.stringify(order));
            renderVocabList();
        }
    }

    function generateCSV(vocabData, fileName) {
        let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
        for (const archive in vocabData) {
            [...vocabData[archive]].reverse().forEach(item => {
                let safeMeaning = item.meaning.replace(/"/g, '""').replace(/\n/g, ' ');
                csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
            });
        }
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url; link.download = `${fileName}.csv`;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }

    function exportArchive(name) {
        const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
        if (vocabData[name]) generateCSV({ [name]: vocabData[name] }, name);
    }

    exportBtn.addEventListener('click', () => {
        const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
        if (Object.keys(vocabData).length === 0) { alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return; }
        const now = new Date();
        const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
        generateCSV(vocabData, ts);
    });

    function renderVocabList() {
        const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
        let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
        vocabListDisplay.innerHTML = '';
        order.filter(name => vocabData[name]).forEach(archive => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'archive-group';
            const header = document.createElement('div');
            header.className = 'archive-header';
            header.innerHTML = `
                <div class="archive-title">ğŸ“‚ ${archive} <span style="font-size:12px;color:#888;">(${vocabData[archive].length}è¯)</span></div>
                <div class="archive-actions">
                    <button class="icon-btn" onclick="exportArchive('${archive.replace(/'/g,"\\'")}')">ğŸ’¾</button>
                    <button class="icon-btn" onclick="renameArchive('${archive.replace(/'/g,"\\'")}')">âœï¸</button>
                    <button class="icon-btn" onclick="deleteArchive('${archive.replace(/'/g,"\\'")}')">ğŸ—‘ï¸</button>
                </div>`;
            groupDiv.appendChild(header);
            vocabData[archive].forEach(item => {
                const parts = item.meaning.split('\nã€è‹±ã€‘');
                let cnText = parts[0].replace('ã€ä¸­ã€‘', '');
                let enText = parts[1] || '';
                const wordDiv = document.createElement('div');
                wordDiv.className = 'word-item';
                wordDiv.innerHTML = `
                    <div class="word-content">
                        <div class="word-header">
                            <span class="word-word">${item.word}</span>
                            <button class="audio-btn" onclick="speakWord('${item.word.replace(/'/g,"\\'")}')">ğŸ”Š</button>
                        </div>
                        <div class="word-meaning">
                            <div class="word-meaning-cn">${cnText}</div>
                            <div style="color:#888;font-size:13px;">${enText}</div>
                        </div>
                    </div>
                    <div class="action-btns">
                        <button class="icon-btn" onclick="editWord('${archive.replace(/'/g,"\\'")}','${item.word.replace(/'/g,"\\'")}')">âœï¸</button>
                        <button class="icon-btn" onclick="deleteWord('${archive.replace(/'/g,"\\'")}','${item.word.replace(/'/g,"\\'")}')">ğŸ—‘ï¸</button>
                    </div>`;
                groupDiv.appendChild(wordDiv);
            });
            vocabListDisplay.appendChild(groupDiv);
        });
    }
    renderVocabList();

    // é¢„çƒ­ç³»ç»Ÿ voices
    if (DEVICE_TYPE !== 'iPhone') window.speechSynthesis.getVoices();
</script>
</body>
</html>
