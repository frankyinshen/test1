<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v4.4.1</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #000; padding: 3px 10px; border-radius: 12px; color: #fff; font-weight: bold; letter-spacing: 0.5px;}
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        .btn-export-all { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; }
        
        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5; text-align: left;}
        .cn-meaning { color: #d9534f; font-weight: bold; margin-bottom: 5px; display: block; }
        
        /* éŸ³è‰²è°ƒè¯•é¢æ¿ */
        #voiceDebug { font-size: 11px; color: #555; margin-top: 8px; white-space: pre-wrap; text-align: left; background: #f2f2f7; padding: 8px 10px; border-radius: 8px; display: none; word-break: break-all; }
        #listVoicesBtn { margin-top: 10px; background: #f2f2f7; border: none; padding: 7px 14px; border-radius: 8px; font-size: 13px; cursor: pointer; color: #555; }
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 25px; border: 1px solid #e5e5ea; border-radius: 12px; overflow: hidden; }
        .archive-header { background: #f8f8f8; padding: 12px 15px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e5ea;}
        .archive-title { flex: 1; display: flex; align-items: center; gap: 5px; }
        .archive-actions { display: flex; gap: 8px; }
        
        .word-item { padding: 15px; border-bottom: 1px solid #f2f2f7; display: flex; justify-content: space-between; align-items: flex-start;}
        .word-item:last-child { border-bottom: none; }
        .word-content { display: flex; flex-direction: column; flex: 1; margin-right: 10px; }
        .word-header { display: flex; align-items: center; gap: 8px; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        
        .audio-btn { background: #e5f1ff; color: #007aff; border: none; border-radius: 50%; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }
        
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; line-height: 1.5; }
        .word-meaning-cn { color: #d9534f; font-weight: 600; margin-bottom: 3px; }
        
        .action-btns { display: flex; gap: 5px; }
        .icon-btn { background: #f2f2f7; border: none; font-size: 14px; cursor: pointer; padding: 6px 10px; border-radius: 8px; }
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬
            <span class="version-tag">v4.4.1-iPad11111</span>
        </h2>
        <div class="input-group"><label for="archiveName">å½’æ¡£åç§°:</label><input type="text" id="archiveName"></div>
        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        <div id="resultWord">...</div>
        <div id="meaning">éœ€è¦ç©ºæ ¼æ—¶ï¼Œè¯·è¯» "zip"</div>
        <div id="voiceDebug"></div>
        <button id="listVoicesBtn">ğŸ” åˆ—å‡ºæ‰€æœ‰è‹±æ–‡éŸ³è‰²ï¼ˆè°ƒè¯•ç”¨ï¼‰</button>
    </div>

    <div class="card word-list">
        <h2>ğŸ“š ä½ çš„ç”Ÿè¯æœ¬ <button id="exportBtn" class="btn-export-all">ğŸ’¾ å¯¼å‡ºå…¨éƒ¨</button></h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');
        const voiceDebug = document.getElementById('voiceDebug');

        // ============================================================
        // ã€v4.4.1 æ–°å¢ã€‘è®¾å¤‡æ£€æµ‹ & æœ€ä¼˜éŸ³è‰²é€‰æ‹©
        // ============================================================

        /**
         * æ£€æµ‹å½“å‰è®¾å¤‡ç±»å‹ã€‚
         * æ³¨æ„ï¼šiPadOS 13+ å°† UA ä¼ªè£…æˆ Macintoshï¼Œéœ€è¦ç”¨ maxTouchPoints æ¥åŒºåˆ†ã€‚
         */
        function getDeviceType() {
            const ua = navigator.userAgent;
            if (/iPad/.test(ua)) return 'iPad';
            if (/iPhone/.test(ua)) return 'iPhone';
            // iPadOS 13+ ä¼ªè£…æˆ Macï¼Œä½†è§¦ç‚¹æ•° > 1
            if (/Macintosh/.test(ua) && navigator.maxTouchPoints > 1) return 'iPad';
            return 'other';
        }

        const DEVICE_TYPE = getDeviceType();

        /**
         * åœ¨å·²åŠ è½½çš„ voices åˆ—è¡¨ä¸­ï¼ŒæŒ‰ä¼˜å…ˆçº§æŒ‘é€‰æœ€ä½³è‹±æ–‡éŸ³è‰²ã€‚
         * ä¼˜å…ˆçº§ï¼šEnhanced/Premium > åå¥½åç§°åˆ—è¡¨ > ä»»æ„ en-US > ä»»æ„ en-*
         */
        function pickBestEnglishVoice(voices) {
            if (!voices || voices.length === 0) return null;

            // è´¨é‡å…³é”®è¯ï¼šåŒæ—¶è¦†ç›–è‹±æ–‡åå’Œä¸­æ–‡åï¼ˆç³»ç»Ÿè¯­è¨€ä¸ºä¸­æ–‡æ—¶éŸ³è‰²åæ˜¯ä¸­æ–‡ï¼‰
            // ä¾‹å¦‚ "Ava Enhanced" åœ¨ä¸­æ–‡ç³»ç»Ÿé‡Œå« "Avaï¼ˆä¼˜åŒ–éŸ³è´¨ï¼‰"
            const qualityKeywords = ['enhanced', 'premium', 'neural', 'ä¼˜åŒ–', 'å¢å¼º', 'é«˜è´¨'];

            // ç¬¬ä¸€ä¼˜å…ˆï¼šåå­—å« Ava ä¸”å«è´¨é‡å…³é”®è¯ï¼ˆç²¾ç¡®å‘½ä¸­ç”¨æˆ·ä¸‹è½½çš„ä¼˜åŒ–ç‰ˆ Avaï¼‰
            for (const kw of qualityKeywords) {
                const v = voices.find(v =>
                    v.lang.startsWith('en') &&
                    v.name.toLowerCase().includes('ava') &&
                    v.name.includes(kw)   // ä¸­æ–‡å…³é”®è¯åŒºåˆ†å¤§å°å†™æ— æ‰€è°“ï¼Œè‹±æ–‡ç”¨å°å†™
                );
                if (v) return v;
            }

            // ç¬¬äºŒä¼˜å…ˆï¼šä»»æ„å«è´¨é‡å…³é”®è¯çš„è‹±æ–‡éŸ³è‰²ï¼ˆä¼˜åŒ–ç‰ˆ Samantha ç­‰ï¼‰
            const preferredNames = ['Samantha', 'Allison', 'Susan', 'Zoe', 'Nicky', 'Moira', 'Tessa', 'Karen'];
            for (const kw of qualityKeywords) {
                for (const name of preferredNames) {
                    const v = voices.find(v =>
                        v.lang.startsWith('en') &&
                        v.name.toLowerCase().includes(name.toLowerCase()) &&
                        v.name.includes(kw)
                    );
                    if (v) return v;
                }
                // ä»»æ„å«è´¨é‡å…³é”®è¯çš„è‹±æ–‡éŸ³è‰²
                const v = voices.find(v => v.lang.startsWith('en') && v.name.includes(kw));
                if (v) return v;
            }

            // ç¬¬ä¸‰ä¼˜å…ˆï¼šAvaï¼ˆæ— è´¨é‡æ ‡è®°ï¼Œå…œåº•ï¼‰
            const ava = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes('ava'));
            if (ava) return ava;

            // ç¬¬å››ä¼˜å…ˆï¼šå…¶ä»–åå¥½åç§°
            for (const name of preferredNames) {
                const v = voices.find(v =>
                    v.lang.startsWith('en') &&
                    v.name.toLowerCase().includes(name.toLowerCase())
                );
                if (v) return v;
            }

            // å…œåº•ï¼šä»»æ„ en-USï¼Œå†ä»»æ„è‹±æ–‡
            return voices.find(v => v.lang === 'en-US') ||
                   voices.find(v => v.lang.startsWith('en')) || null;
        }

        /**
         * ä¸»æœ—è¯»å‡½æ•°ã€‚
         * - iPhoneï¼šæ²¿ç”¨åŸæœ‰ç›´æ¥ speak() æ–¹å¼ï¼ˆåŸå·²èƒ½è‡ªåŠ¨ç”¨å¥½éŸ³è‰²ï¼‰ã€‚
         * - iPad / å…¶ä»–ï¼šå¼‚æ­¥ç­‰å¾… voices åˆ—è¡¨åŠ è½½å®Œæ¯•åï¼Œä¸»åŠ¨æŒ‘é€‰æœ€ä¼˜éŸ³è‰²ã€‚
         */
        function speakWord(word) {
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US';
            utterance.rate = 0.9;

            if (DEVICE_TYPE === 'iPhone') {
                // iPhone ç»´æŒåŸé€»è¾‘ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åŒ¹é…å·²è®¾ç½®çš„ Ava Enhanced
                window.speechSynthesis.speak(utterance);
                return;
            }

            // iPad / å…¶ä»–å¹³å°ï¼šä¸»åŠ¨è·å–å¹¶æŒ‡å®šæœ€ä¼˜éŸ³è‰²
            const doSpeak = () => {
                const voices = window.speechSynthesis.getVoices();
                const best = pickBestEnglishVoice(voices);
                if (best) {
                    utterance.voice = best;
                    voiceDebug.style.display = 'block';
                    voiceDebug.innerText = `ğŸ”Š å½“å‰éŸ³è‰²: "${best.name}" | ${best.lang}`;
                } else {
                    voiceDebug.style.display = 'block';
                    voiceDebug.innerText = 'ğŸ”Š éŸ³è‰²: ç³»ç»Ÿé»˜è®¤';
                }
                window.speechSynthesis.speak(utterance);
            };

            const voices = window.speechSynthesis.getVoices();
            if (voices && voices.length > 0) {
                // voices å·²å°±ç»ªï¼Œç›´æ¥é€‰
                doSpeak();
            } else {
                // voices å°šæœªåŠ è½½ï¼Œç­‰ voiceschanged äº‹ä»¶ï¼ˆiPad å¸¸è§æƒ…å†µï¼‰
                const onVoicesReady = () => {
                    window.speechSynthesis.onvoiceschanged = null;
                    doSpeak();
                };
                window.speechSynthesis.onvoiceschanged = onVoicesReady;
                // ä¿é™©ï¼š2ç§’åè‹¥è¿˜æ²¡è§¦å‘ï¼Œå¼ºåˆ¶ç”¨é»˜è®¤éŸ³è‰²æ’­æ”¾
                setTimeout(() => {
                    if (window.speechSynthesis.onvoiceschanged === onVoicesReady) {
                        window.speechSynthesis.onvoiceschanged = null;
                        voiceDebug.innerText = 'ğŸ”Š éŸ³è‰²: è¶…æ—¶ï¼Œä½¿ç”¨é»˜è®¤';
                        window.speechSynthesis.speak(utterance);
                    }
                }, 2000);
            }
        }

        // ============================================================
        // ä»¥ä¸‹ä¸ºåŸæœ‰ä»£ç ï¼Œæœªä½œä»»ä½•æ”¹åŠ¨
        // ============================================================

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isSystemBusy = false; 
        let fallbackTimer = null; 
        let hasActuallyStarted = false; 

        function resetRecognition() {
            if (recognition) {
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            clearTimeout(fallbackTimer);
        }

        const startRecording = (e) => {
            e.preventDefault();
            if (isSystemBusy) return; 
            isSystemBusy = true;
            hasActuallyStarted = false; 
            rawTranscriptDisplay.innerText = "";
            resetRecognition();
            if (!SpeechRecognition) { statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚"; isSystemBusy = false; return; }

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                hasActuallyStarted = true; 
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬...";
                statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
            };

            recognition.onresult = async (event) => {
                clearTimeout(fallbackTimer); 
                let transcript = event.results[0][0].transcript.toLowerCase();
                rawTranscriptDisplay.innerText = `[å¬åˆ°å†…å®¹]: "${transcript}"`;
                
                let processed = transcript.replace(/\bzip\b/g, '_');
                let word = processed.replace(/[^a-z\s_]/g, ''); 
                word = word.replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ æœªè¯†åˆ«å‡ºæœ‰æ•ˆå­—ç¬¦ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨ç¿»è¯‘æŸ¥è¯¢ä¸­...";
                await processWord(word); 
            };

            recognition.onerror = (event) => {
                clearTimeout(fallbackTimer);
                statusText.innerText = `âŒ ${event.error}`;
            };

            recognition.onend = () => {
                clearTimeout(fallbackTimer);
                isSystemBusy = false; 
                recordBtn.classList.remove('busy', 'recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                if(statusText.innerText.includes("ç­‰å¾…ç³»ç»Ÿå›ä¼ ")) {
                    statusText.innerText = "âš ï¸ ç³»ç»Ÿæœªè¿”å›æ•°æ®ï¼Œè¯·é‡è¯»ã€‚";
                }
            };

            try { recognition.start(); } catch (err) { isSystemBusy = false; }
        };

        const stopRecording = (e) => {
            e.preventDefault();
            if (!isSystemBusy) return; 
            if (!hasActuallyStarted) {
                resetRecognition(); isSystemBusy = false;
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                statusText.innerText = "æƒé™å·²æ›´æ–°ï¼Œè¯·é‡æ–°æŒ‰ä½ã€‚";
                return;
            }
            recordBtn.classList.remove('recording');
            recordBtn.classList.add('busy');
            recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
            statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿå›ä¼ ...";
            fallbackTimer = setTimeout(() => {
                if (isSystemBusy && recognition) { try { recognition.stop(); } catch(err) {} }
            }, 2500); 
        };

        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);

        async function processWord(word, specificArchive = null) {
            let enMeaning = "æš‚æ— è‹±æ–‡é‡Šä¹‰ã€‚";
            let cnMeaning = "æš‚æ— ä¸­æ–‡é‡Šä¹‰ã€‚";
            const safeWordUrl = encodeURIComponent(word);
            try {
                const transRes = await fetch(`https://api.mymemory.translated.net/get?q=${safeWordUrl}&langpair=en|zh-CN`);
                const transData = await transRes.json();
                if (transData && transData.responseData) {
                    let text = transData.responseData.translatedText;
                    if (text.toLowerCase() !== word.toLowerCase()) { cnMeaning = text; }
                }
                try {
                    const dictRes = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${safeWordUrl}`);
                    if (dictRes.ok) {
                        const dictData = await dictRes.json();
                        enMeaning = dictData[0].meanings[0].definitions[0].definition;
                    }
                } catch(e) {}
                statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
            } catch (error) { statusText.innerText = "âš ï¸ ç½‘ç»œå¼‚å¸¸ï¼Œä»…ä¿å­˜æ‹¼å†™"; }
            const combinedMeaning = `ã€ä¸­ã€‘${cnMeaning}\nã€è‹±ã€‘${enMeaning}`;
            meaningDisplay.innerHTML = `<span class="cn-meaning">${cnMeaning}</span><span class="en-meaning">${enMeaning}</span>`;
            resultWordDisplay.innerText = word;
            saveWord(word, combinedMeaning, specificArchive);
            renderVocabList();
        }

        function saveWord(word, meaning, specificArchive) {
            const archiveName = specificArchive || (document.getElementById('archiveName').value || today);
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            vocabData[archiveName] = vocabData[archiveName].filter(w => w.word !== word);
            vocabData[archiveName].unshift({ word, meaning });
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            order = order.filter(name => name !== archiveName);
            order.unshift(archiveName);
            localStorage.setItem('myVocabBook_order', JSON.stringify(order));
        }

        function editWord(archive, oldWord) {
            const newWord = prompt(`è¯·ä¿®æ”¹ "${oldWord}"ï¼š`, oldWord);
            if (newWord && newWord.trim() !== "" && newWord !== oldWord) {
                const cleanWord = newWord.replace(/[^a-zA-Z\s]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
                if(!cleanWord) { alert("åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ï¼"); return; }
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== oldWord);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                statusText.innerText = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${cleanWord} ...`;
                processWord(cleanWord, archive); 
            }
        }

        function deleteWord(archive, word) {
            if(confirm(`ç¡®å®šåˆ é™¤å•è¯ "${word}" å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== word);
                if (vocabData[archive].length === 0) {
                    delete vocabData[archive];
                    let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                    order = order.filter(name => name !== archive);
                    localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                }
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }
        
        function renameArchive(oldName) {
            const newName = prompt("è¯·è¾“å…¥æ–°çš„å½’æ¡£åç§°ï¼š", oldName);
            if (newName && newName.trim() && newName !== oldName) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                if (vocabData[newName]) { alert("è¯¥å½’æ¡£åç§°å·²å­˜åœ¨ï¼"); return; }
                vocabData[newName] = vocabData[oldName];
                delete vocabData[oldName];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                const index = order.indexOf(oldName);
                if (index > -1) order[index] = newName;
                localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                if(document.getElementById('archiveName').value === oldName) { document.getElementById('archiveName').value = newName; }
                renderVocabList();
            }
        }
        
        function deleteArchive(name) {
            if (confirm(`âš ï¸ å±é™©æ“ä½œï¼š\nç¡®å®šè¦å½»åº•åˆ é™¤å½’æ¡£ã€${name}ã€‘å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                delete vocabData[name];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                order = order.filter(n => n !== name);
                localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                renderVocabList();
            }
        }

        function generateCSV(vocabData, fileName) {
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                const exportList = [...vocabData[archive]].reverse();
                exportList.forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""').replace(/\n/g, ' ');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `${fileName}.csv`; 
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportArchive(name) {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if(vocabData[name]) { generateCSV({ [name]: vocabData[name] }, name); }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) { alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return; }
            const now = new Date();
            const timeStr = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            generateCSV(vocabData, timeStr);
        });

        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            vocabListDisplay.innerHTML = '';
            const validOrder = order.filter(name => vocabData[name]);
            validOrder.forEach(archive => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `
                    <div class="archive-title">ğŸ“‚ ${archive} <span style="font-size:12px;color:#888;">(${vocabData[archive].length}è¯)</span></div>
                    <div class="archive-actions">
                        <button class="icon-btn" onclick="exportArchive('${archive.replace(/'/g, "\\'")}')">ğŸ’¾</button>
                        <button class="icon-btn" onclick="renameArchive('${archive.replace(/'/g, "\\'")}')">âœï¸</button>
                        <button class="icon-btn danger" onclick="deleteArchive('${archive.replace(/'/g, "\\'")}')">ğŸ—‘ï¸</button>
                    </div>`;
                groupDiv.appendChild(header);
                vocabData[archive].forEach(item => {
                    const meaningParts = item.meaning.split('\nã€è‹±ã€‘');
                    let cnText = meaningParts[0].replace('ã€ä¸­ã€‘', '');
                    let enText = meaningParts[1] || '';
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    wordDiv.innerHTML = `
                        <div class="word-content">
                            <div class="word-header">
                                <span class="word-word">${item.word}</span>
                                <button class="audio-btn" onclick="speakWord('${item.word.replace(/'/g, "\\'")}')">ğŸ”Š</button>
                            </div>
                            <div class="word-meaning">
                                <div class="word-meaning-cn">${cnText}</div>
                                <div style="color:#888; font-size:13px;">${enText}</div>
                            </div>
                        </div>
                        <div class="action-btns">
                            <button class="icon-btn" onclick="editWord('${archive.replace(/'/g, "\\'")}', '${item.word.replace(/'/g, "\\'")}')">âœï¸</button>
                            <button class="icon-btn danger" onclick="deleteWord('${archive.replace(/'/g, "\\'")}', '${item.word.replace(/'/g, "\\'")}')">ğŸ—‘ï¸</button>
                        </div>`;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            });
        }
        renderVocabList();

        // è°ƒè¯•ï¼šåˆ—å‡ºæ‰€æœ‰å¯ç”¨è‹±æ–‡éŸ³è‰²
        document.getElementById('listVoicesBtn').addEventListener('click', () => {
            const doList = () => {
                const all = window.speechSynthesis.getVoices();
                const enVoices = all.filter(v => v.lang.startsWith('en'));
                voiceDebug.style.display = 'block';
                if (enVoices.length === 0) {
                    voiceDebug.innerText = 'âš ï¸ æœªæ‰¾åˆ°ä»»ä½•è‹±æ–‡éŸ³è‰²ï¼Œè¯·ç¨åå†è¯•ã€‚';
                    return;
                }
                voiceDebug.innerText = `å…±æ‰¾åˆ° ${enVoices.length} ä¸ªè‹±æ–‡éŸ³è‰²ï¼š\n` +
                    enVoices.map((v, i) => `${i+1}. "${v.name}" | ${v.lang}`).join('\n');
            };
            const voices = window.speechSynthesis.getVoices();
            if (voices && voices.length > 0) {
                doList();
            } else {
                voiceDebug.style.display = 'block';
                voiceDebug.innerText = 'â³ æ­£åœ¨åŠ è½½éŸ³è‰²åˆ—è¡¨...';
                window.speechSynthesis.onvoiceschanged = () => {
                    window.speechSynthesis.onvoiceschanged = null;
                    doList();
                };
                window.speechSynthesis.getVoices();
            }
        });

        // é¡µé¢åŠ è½½åé¢„çƒ­ voices åˆ—è¡¨ï¼ˆè§£å†³ iPad é¦–æ¬¡è°ƒç”¨å»¶è¿Ÿé—®é¢˜ï¼‰
        if (DEVICE_TYPE !== 'iPhone') {
            window.speechSynthesis.getVoices();
        }
    </script>
</body>
</html>
