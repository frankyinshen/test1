<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v4.4.1</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #000; padding: 3px 10px; border-radius: 12px; color: #fff; font-weight: bold; letter-spacing: 0.5px;}
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        .btn-export-all { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; }
        
        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5; text-align: left;}
        .cn-meaning { color: #d9534f; font-weight: bold; margin-bottom: 5px; display: block; }
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 25px; border: 1px solid #e5e5ea; border-radius: 12px; overflow: hidden; }
        .archive-header { background: #f8f8f8; padding: 12px 15px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e5ea;}
        .archive-title { flex: 1; display: flex; align-items: center; gap: 5px; }
        .archive-actions { display: flex; gap: 8px; }
        
        .word-item { padding: 15px; border-bottom: 1px solid #f2f2f7; display: flex; justify-content: space-between; align-items: flex-start;}
        .word-item:last-child { border-bottom: none; }
        .word-content { display: flex; flex-direction: column; flex: 1; margin-right: 10px; }
        .word-header { display: flex; align-items: center; gap: 8px; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        
        .audio-btn { background: #e5f1ff; color: #007aff; border: none; border-radius: 50%; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }
        
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; line-height: 1.5; }
        .word-meaning-cn { color: #d9534f; font-weight: 600; margin-bottom: 3px; }
        
        .action-btns { display: flex; gap: 5px; }
        .icon-btn { background: #f2f2f7; border: none; font-size: 14px; cursor: pointer; padding: 6px 10px; border-radius: 8px; }
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬
            <span class="version-tag">v4.4.1-iPadä¿®å¤</span>
        </h2>
        <div class="input-group"><label for="archiveName">å½’æ¡£åç§°:</label><input type="text" id="archiveName"></div>
        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        <div id="resultWord">...</div>
        <div id="meaning">éœ€è¦ç©ºæ ¼æ—¶ï¼Œè¯·è¯» "zip"</div>
    </div>

    <div class="card word-list">
        <h2>ğŸ“š ä½ çš„ç”Ÿè¯æœ¬ <button id="exportBtn" class="btn-export-all">ğŸ’¾ å¯¼å‡ºå…¨éƒ¨</button></h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isSystemBusy = false; 
        let fallbackTimer = null; 
        let hasActuallyStarted = false; 

        function resetRecognition() {
            if (recognition) {
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            clearTimeout(fallbackTimer);
        }

        const startRecording = (e) => {
            e.preventDefault();
            if (isSystemBusy) return; 
            isSystemBusy = true;
            hasActuallyStarted = false; 
            rawTranscriptDisplay.innerText = "";
            resetRecognition();
            if (!SpeechRecognition) { statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚"; isSystemBusy = false; return; }

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                hasActuallyStarted = true; 
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬...";
                statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
            };

            recognition.onresult = async (event) => {
                clearTimeout(fallbackTimer); 
                let transcript = event.results[0][0].transcript.toLowerCase();
                rawTranscriptDisplay.innerText = `[å¬åˆ°å†…å®¹]: "${transcript}"`;
                
                // ã€V4.4.0 æ ¸å¿ƒå‡çº§ï¼šä½¿ç”¨ "zip" ä½œä¸ºç©ºæ ¼å‘½ä»¤ã€‘
                let processed = transcript.replace(/\bzip\b/g, '_');
                let word = processed.replace(/[^a-z\s_]/g, ''); 
                word = word.replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ æœªè¯†åˆ«å‡ºæœ‰æ•ˆå­—ç¬¦ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨ç¿»è¯‘æŸ¥è¯¢ä¸­...";
                await processWord(word); 
            };

            recognition.onerror = (event) => {
                clearTimeout(fallbackTimer);
                statusText.innerText = `âŒ ${event.error}`;
            };

            recognition.onend = () => {
                clearTimeout(fallbackTimer);
                isSystemBusy = false; 
                recordBtn.classList.remove('busy', 'recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                if(statusText.innerText.includes("ç­‰å¾…ç³»ç»Ÿå›ä¼ ")) {
                    statusText.innerText = "âš ï¸ ç³»ç»Ÿæœªè¿”å›æ•°æ®ï¼Œè¯·é‡è¯»ã€‚";
                }
            };

            try { recognition.start(); } catch (err) { isSystemBusy = false; }
        };

        const stopRecording = (e) => {
            e.preventDefault();
            if (!isSystemBusy) return; 
            if (!hasActuallyStarted) {
                resetRecognition(); isSystemBusy = false;
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                statusText.innerText = "æƒé™å·²æ›´æ–°ï¼Œè¯·é‡æ–°æŒ‰ä½ã€‚";
                return;
            }
            recordBtn.classList.remove('recording');
            recordBtn.classList.add('busy');
            recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
            statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿå›ä¼ ...";
            fallbackTimer = setTimeout(() => {
                if (isSystemBusy && recognition) { try { recognition.stop(); } catch(err) {} }
            }, 2500); 
        };

        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);

        async function processWord(word, specificArchive = null) {
            let enMeaning = "æš‚æ— è‹±æ–‡é‡Šä¹‰ã€‚";
            let cnMeaning = "æš‚æ— ä¸­æ–‡é‡Šä¹‰ã€‚";
            const safeWordUrl = encodeURIComponent(word);
            try {
                const transRes = await fetch(`https://api.mymemory.translated.net/get?q=${safeWordUrl}&langpair=en|zh-CN`);
                const transData = await transRes.json();
                if (transData && transData.responseData) {
                    let text = transData.responseData.translatedText;
                    if (text.toLowerCase() !== word.toLowerCase()) { cnMeaning = text; }
                }
                try {
                    const dictRes = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${safeWordUrl}`);
                    if (dictRes.ok) {
                        const dictData = await dictRes.json();
                        enMeaning = dictData[0].meanings[0].definitions[0].definition;
                    }
                } catch(e) {}
                statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
            } catch (error) { statusText.innerText = "âš ï¸ ç½‘ç»œå¼‚å¸¸ï¼Œä»…ä¿å­˜æ‹¼å†™"; }
            const combinedMeaning = `ã€ä¸­ã€‘${cnMeaning}\nã€è‹±ã€‘${enMeaning}`;
            meaningDisplay.innerHTML = `<span class="cn-meaning">${cnMeaning}</span><span class="en-meaning">${enMeaning}</span>`;
            resultWordDisplay.innerText = word;
            saveWord(word, combinedMeaning, specificArchive);
            renderVocabList();
        }

        function saveWord(word, meaning, specificArchive) {
            const archiveName = specificArchive || (document.getElementById('archiveName').value || today);
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            vocabData[archiveName] = vocabData[archiveName].filter(w => w.word !== word);
            vocabData[archiveName].unshift({ word, meaning });
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            order = order.filter(name => name !== archiveName);
            order.unshift(archiveName);
            localStorage.setItem('myVocabBook_order', JSON.stringify(order));
        }

        function editWord(archive, oldWord) {
            const newWord = prompt(`è¯·ä¿®æ”¹ "${oldWord}"ï¼š`, oldWord);
            if (newWord && newWord.trim() !== "" && newWord !== oldWord) {
                const cleanWord = newWord.replace(/[^a-zA-Z\s]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
                if(!cleanWord) { alert("åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ï¼"); return; }
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== oldWord);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                statusText.innerText = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${cleanWord} ...`;
                processWord(cleanWord, archive); 
            }
        }

        function deleteWord(archive, word) {
            if(confirm(`ç¡®å®šåˆ é™¤å•è¯ "${word}" å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== word);
                if (vocabData[archive].length === 0) {
                    delete vocabData[archive];
                    let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                    order = order.filter(name => name !== archive);
                    localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                }
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }
        
        function renameArchive(oldName) {
            const newName = prompt("è¯·è¾“å…¥æ–°çš„å½’æ¡£åç§°ï¼š", oldName);
            if (newName && newName.trim() && newName !== oldName) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                if (vocabData[newName]) { alert("è¯¥å½’æ¡£åç§°å·²å­˜åœ¨ï¼"); return; }
                vocabData[newName] = vocabData[oldName];
                delete vocabData[oldName];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                const index = order.indexOf(oldName);
                if (index > -1) order[index] = newName;
                localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                if(document.getElementById('archiveName').value === oldName) { document.getElementById('archiveName').value = newName; }
                renderVocabList();
            }
        }
        
        function deleteArchive(name) {
            if (confirm(`âš ï¸ å±é™©æ“ä½œï¼š\nç¡®å®šè¦å½»åº•åˆ é™¤å½’æ¡£ã€${name}ã€‘å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                delete vocabData[name];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
                order = order.filter(n => n !== name);
                localStorage.setItem('myVocabBook_order', JSON.stringify(order));
                renderVocabList();
            }
        }

        // ==================== è¯­éŸ³åˆæˆå¢å¼º (iPad ä¸“ç”¨é«˜è´¨é‡éŸ³è‰²) ====================
        // è®¾å¤‡æ£€æµ‹
        function isIPhone() {
            return /iPhone/i.test(navigator.userAgent);
        }

        function isIPad() {
            // æ£€æµ‹ iPad (åŒ…æ‹¬ iPad Pro 2020+ ä¼ªè£…æˆ Mac)
            return /iPad/i.test(navigator.userAgent) || 
                   (/Mac/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1 && !/iPhone/i.test(navigator.userAgent));
        }

        // é«˜è´¨é‡è¯­éŸ³é€‰æ‹©å™¨ (ä¸º iPad å‡†å¤‡)
        function speakWithSelectedVoice(word, voices) {
            // ç­›é€‰è‹±æ–‡è¯­éŸ³ (lang åŒ…å« 'en')
            const englishVoices = voices.filter(v => v.lang && v.lang.includes('en'));
            let selectedVoice = null;

            // ä¼˜å…ˆçº§åŒ¹é… (è¶Šé å‰éŸ³è´¨è¶Šå¥½ï¼Œé’ˆå¯¹ iOS å¸¸ç”¨ä¼˜è´¨è¯­éŸ³)
            const matchers = [
                (v) => v.name.includes('Ava') && v.name.includes('Enhanced'),  // Ava Enhanced (é¡¶çº§)
                (v) => v.name.includes('Ava'),                                 // Ava (é€šå¸¸ä¹Ÿå¾ˆå¥½)
                (v) => v.name.includes('Enhanced'),                            // ä»»ä½• Enhanced ç‰ˆæœ¬ (Samantha Enhancedç­‰)
                (v) => v.name.includes('Samantha') || v.name.includes('Premium'), // Samantha æˆ– Premium
                (v) => v.lang === 'en-US'                                      // ä¿åº•: ç¬¬ä¸€ä¸ªç¾å¼è‹±è¯­
            ];

            for (let matcher of matchers) {
                selectedVoice = englishVoices.find(matcher);
                if (selectedVoice) break;
            }

            if (!selectedVoice && englishVoices.length > 0) {
                selectedVoice = englishVoices[0]; // æœ€åæƒ…å†µé€‰ç¬¬ä¸€ä¸ªè‹±æ–‡è¯­éŸ³
            }

            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US';
            utterance.rate = 0.9;
            if (selectedVoice) utterance.voice = selectedVoice;
            window.speechSynthesis.speak(utterance);
        }

        // iPad ä¸“ç”¨: å®‰å…¨è·å– voices å¹¶æ’­æ”¾ (å¤„ç†å¼‚æ­¥åŠ è½½)
        function speakWithGoodVoice(word) {
            window.speechSynthesis.cancel(); // å…ˆå–æ¶ˆä»»ä½•æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³

            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                speakWithSelectedVoice(word, voices);
            } else {
                // voices å°šæœªåŠ è½½ï¼Œç­‰å¾… voiceschanged äº‹ä»¶ (è®¾ç½®è¶…æ—¶é˜²æ­¢å¡æ­»)
                let timeout = setTimeout(() => {
                    window.speechSynthesis.onvoiceschanged = null;
                    // è¶…æ—¶åé™çº§: æ— æŒ‡å®š voice (ç³»ç»Ÿé»˜è®¤)
                    const utterance = new SpeechSynthesisUtterance(word);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.9;
                    window.speechSynthesis.speak(utterance);
                }, 600);

                window.speechSynthesis.onvoiceschanged = function() {
                    clearTimeout(timeout);
                    window.speechSynthesis.onvoiceschanged = null;
                    const newVoices = window.speechSynthesis.getVoices();
                    if (newVoices.length > 0) {
                        speakWithSelectedVoice(word, newVoices);
                    } else {
                        // ä»ç„¶ä¸ºç©ºï¼Œfallback
                        const utterance = new SpeechSynthesisUtterance(word);
                        utterance.lang = 'en-US';
                        utterance.rate = 0.9;
                        window.speechSynthesis.speak(utterance);
                    }
                };
            }
        }

        // ==================== æ–°ç‰ˆ speakWord (åŒºåˆ† iPhone / iPad) ====================
        // å®Œå…¨è¦†ç›–æ—§ç‰ˆå‡½æ•°ï¼Œä¿è¯ iPhone åŸæœ‰è¡Œä¸ºä¸å˜ï¼ŒiPad ä½¿ç”¨å¢å¼ºé€»è¾‘
        function speakWord(word) {
            if (isIPhone()) {
                // iPhone: ä¿æŒåŸæœ‰ç®€æ´è°ƒç”¨ (é»˜è®¤è¯­éŸ³å°±æ˜¯ Ava Enhanced)
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            } else if (isIPad()) {
                // iPad: ä½¿ç”¨é«˜è´¨é‡è¯­éŸ³é€‰æ‹©é€»è¾‘
                speakWithGoodVoice(word);
            } else {
                // å…¶ä»–è®¾å¤‡ (Windows/Androidç­‰) ä¿æŒåŸæœ‰æ–¹å¼ï¼Œé¿å…æ„å¤–å˜åŒ–
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            }
        }

        function generateCSV(vocabData, fileName) {
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                const exportList = [...vocabData[archive]].reverse();
                exportList.forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""').replace(/\n/g, ' ');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `${fileName}.csv`; 
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportArchive(name) {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if(vocabData[name]) { generateCSV({ [name]: vocabData[name] }, name); }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) { alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return; }
            const now = new Date();
            const timeStr = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            generateCSV(vocabData, timeStr);
        });

        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            let order = JSON.parse(localStorage.getItem('myVocabBook_order')) || [];
            vocabListDisplay.innerHTML = '';
            const validOrder = order.filter(name => vocabData[name]);
            validOrder.forEach(archive => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `
                    <div class="archive-title">ğŸ“‚ ${archive} <span style="font-size:12px;color:#888;">(${vocabData[archive].length}è¯)</span></div>
                    <div class="archive-actions">
                        <button class="icon-btn" onclick="exportArchive('${archive.replace(/'/g, "\\'")}')">ğŸ’¾</button>
                        <button class="icon-btn" onclick="renameArchive('${archive.replace(/'/g, "\\'")}')">âœï¸</button>
                        <button class="icon-btn danger" onclick="deleteArchive('${archive.replace(/'/g, "\\'")}')">ğŸ—‘ï¸</button>
                    </div>`;
                groupDiv.appendChild(header);
                vocabData[archive].forEach(item => {
                    const meaningParts = item.meaning.split('\nã€è‹±ã€‘');
                    let cnText = meaningParts[0].replace('ã€ä¸­ã€‘', '');
                    let enText = meaningParts[1] || '';
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    wordDiv.innerHTML = `
                        <div class="word-content">
                            <div class="word-header">
                                <span class="word-word">${item.word}</span>
                                <button class="audio-btn" onclick="speakWord('${item.word.replace(/'/g, "\\'")}')">ğŸ”Š</button>
                            </div>
                            <div class="word-meaning">
                                <div class="word-meaning-cn">${cnText}</div>
                                <div style="color:#888; font-size:13px;">${enText}</div>
                            </div>
                        </div>
                        <div class="action-btns">
                            <button class="icon-btn" onclick="editWord('${archive.replace(/'/g, "\\'")}', '${item.word.replace(/'/g, "\\'")}')">âœï¸</button>
                            <button class="icon-btn danger" onclick="deleteWord('${archive.replace(/'/g, "\\'")}', '${item.word.replace(/'/g, "\\'")}')">ğŸ—‘ï¸</button>
                        </div>`;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            });
        }
        renderVocabList();
    </script>
</body>
</html>
